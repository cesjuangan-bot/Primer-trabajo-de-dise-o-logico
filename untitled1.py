# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WGfqwqZaRnDqqlTdw_cdoZSve1lVKmfV
"""

!pip install pandas numpy matplotlib scikit-learn

# 1. Importar librerías
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report

# 2. Crear dataset manual
data = {
    "horas_estudio": [1,2,3,4,5,6,7,8,9,10],
    "horas_sueno":   [4,5,5,6,6,7,7,8,8,9],
    "aprobo":        [0,0,0,1,1,1,1,1,1,1]
}
df = pd.DataFrame(data)
print(df)

# 3. Definir variables X (inputs) y y (target)
X = df[["horas_estudio", "horas_sueno"]]
y = df["aprobo"]

# 4. Dividir datos en entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42
)

# 5. Crear el modelo de regresión logística
modelo = LogisticRegression()

# 6. Entrenar el modelo
modelo.fit(X_train, y_train)

# 7. Hacer predicciones
predicciones = modelo.predict(X_test)

# 8. Evaluar exactitud
accuracy = accuracy_score(y_test, predicciones)
print("Exactitud del modelo:", accuracy)

# 9. Matriz de confusión
matriz = confusion_matrix(y_test, predicciones)
print("Matriz de confusión:")
print(matriz)

# 10. Reporte completo
print("Reporte de clasificación:")
print(classification_report(y_test, predicciones))

# 11. Probabilidad de aprobar según horas
nuevos_datos = np.array([[6, 7]])    # 6 horas de estudio, 7 de sueño
prob = modelo.predict_proba(nuevos_datos)
print("Probabilidad de aprobar:", prob)

# 12. Visualización del modelo y los datos
plt.figure(figsize=(8,6))

# Scatter plot de los datos reales
scatter_plot = plt.scatter(df["horas_estudio"], df["horas_sueno"],
            c=df["aprobo"], cmap='bwr', s=80)

plt.xlabel("Horas de estudio")
plt.ylabel("Horas de sueño")
plt.title("Visualización de la Regresión Logística")

# Crear una malla de puntos (grid)
x_min, x_max = df["horas_estudio"].min()-1, df["horas_estudio"].max()+1
y_min, y_max = df["horas_sueno"].min()-1, df["horas_sueno"].max()+1
xx, yy = np.meshgrid(np.linspace(x_min, x_max, 200),
                     np.linspace(y_min, y_max, 200))

# Predecir probabilidad en cada punto del grid
grid = np.c_[xx.ravel(), yy.ravel()]
probs = modelo.predict_proba(grid)[:,1].reshape(xx.shape)

# Dibujar la frontera de decisión
plt.contour(xx, yy, probs, levels=[0.5], linewidths=2)

plt.colorbar(scatter_plot, label="Probabilidad de aprobar")
plt.show()

